#![allow(dead_code)]

use std::{
    ffi::{CStr, CString},
    os::raw::{c_char, c_uint, c_ulong},
    ptr::{null_mut, NonNull},
};

pub fn get_crate_type() -> Option<String> {
    unsafe { crate_type }.map(|p| {
        unsafe { CStr::from_ptr(p.as_ptr()) }
            .to_str()
            .unwrap()
            .to_string()
    })
}

#[repr(transparent)]
pub struct Location(c_uint);

pub const UNKNOWN_LOCATION: Location = Location(0);
pub const BUILTINS_LOCATION: Location = Location(1);

// TODO: autogenerate this
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum IntegerTypeKind {
    Char,
    SignedChar,
    UnsignedChar,
    Short,
    UnsignedShort,
    Int,
    UnsignedInt,
    Long,
    UnsignedLong,
    LongLong,
    UnsignedLongLong,

    IntN0,
    UnsignedIntN0,
    IntN1,
    UnsignedIntN1,
    IntN2,
    UnsignedIntN2,
    IntN3,
    UnsignedIntN3,

    None,
}

// TODO: autogenerate this
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum SizeTypeKind {
    UnsignedBytes,
    SignedBytes,
    UnsignedBits,
    SignedBits,
}

// TODO: autogenerate this
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TreeIndex {
    ErrorMark,
    IntqiType,
    InthiType,
    IntsiType,
    IntdiType,
    InttiType,
    UintqiType,
    UinthiType,
    UintsiType,
    UintdiType,
    UinttiType,
    AtomicqiType,
    AtomichiType,
    AtomicsiType,
    AtomicdiType,
    AtomictiType,
    Uint16Type,
    Uint32Type,
    Uint64Type,
    Void,
    IntegerZero,
    IntegerOne,
    IntegerThree,
    IntegerMinusOne,
    NullPointer,
    SizeZero,
    SizeOne,
    BitsizeZero,
    BitsizeOne,
    BitsizeUnit,
    Public,
    Protected,
    Private,
    BooleanFalse,
    BooleanTrue,
    FloatType,
    DoubleType,
    LongDoubleType,
    Float16Type,
    Float32Type,
    Float64Type,
    Float128Type,
    Float32XType,
    Float64XType,
    Float128XType,
    ComplexIntegerType,
    ComplexFloatType,
    ComplexDoubleType,
    ComplexLongDoubleType,
    ComplexFloat16Type,
    ComplexFloat32Type,
    ComplexFloat64Type,
    ComplexFloat128Type,
    ComplexFloat32XType,
    ComplexFloat64XType,
    ComplexFloat128XType,
    FloatPtrType,
    DoublePtrType,
    LongDoublePtrType,
    IntegerPtrType,
    VoidType,
    PtrType,
    ConstPtrType,
    SizeType,
    PidType,
    PtrDiffType,
    VaListType,
    VaListGprCounterField,
    VaListFprCounterField,
    BooleanType,
    FilePtrType,
    ConstTmPtrType,
    FenvTPtrType,
    ConstFenvTPtrType,
    FexceptTPtrType,
    ConstFexceptTPtrType,
    PointerSizedType,
    DFloat32Type,
    DFloat64Type,
    DFloat128Type,
    VoidListNode,
    MainIdentifier,
    SatSfractType,
    SatFractType,
    SatLfractType,
    SatLlfractType,
    SatUsfractType,
    SatUfractType,
    SatUlfractType,
    SatUllfractType,
    SfractType,
    FractType,
    LfractType,
    LlfractType,
    UsfractType,
    UfractType,
    UlfractType,
    UllfractType,
    SatSaccumType,
    SatAccumType,
    SatLaccumType,
    SatLlaccumType,
    SatUsaccumType,
    SatUaccumType,
    SatUlaccumType,
    SatUllaccumType,
    SaccumType,
    AccumType,
    LaccumType,
    LlaccumType,
    UsaccumType,
    UaccumType,
    UlaccumType,
    UllaccumType,
    QqType,
    HqType,
    SqType,
    DqType,
    TqType,
    UqqType,
    UhqType,
    UsqType,
    UdqType,
    UtqType,
    SatQqType,
    SatHqType,
    SatSqType,
    SatDqType,
    SatTqType,
    SatUqqType,
    SatUhqType,
    SatUsqType,
    SatUdqType,
    SatUtqType,
    HaType,
    SaType,
    DaType,
    TaType,
    UhaType,
    UsaType,
    UdaType,
    UtaType,
    SatHaType,
    SatSaType,
    SatDaType,
    SatTaType,
    SatUhaType,
    SatUsaType,
    SatUdaType,
    SatUtaType,
    OptimizationDefault,
    OptimizationCurrent,
    TargetOptionDefault,
    TargetOptionCurrent,
    CurrentTargetPragma,
    CurrentOptimizePragma,
    ChrecDontKnow,
    ChrecKnown,

    Max,
}

// TODO: autogenerate this
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BuiltinFunction {
    None,
    Acos,
    Acosf,
    Acosh,
    Acoshf,
    Acoshl,
    Acosl,
    AlignedAlloc,
    Asin,
    Asinf,
    Asinh,
    Asinhf,
    Asinhl,
    Asinl,
    Atan,
    Atan2,
    Atan2f,
    Atan2l,
    Atanf,
    Atanh,
    Atanhf,
    Atanhl,
    Atanl,
    Cbrt,
    Cbrtf,
    Cbrtl,
    Ceil,
    Ceilf,
    Ceill,
    Ceilf16,
    Ceilf32,
    Ceilf64,
    Ceilf128,
    Ceilf32x,
    Ceilf64x,
    Ceilf128x,
    Copysign,
    Copysignf,
    Copysignl,
    Copysignf16,
    Copysignf32,
    Copysignf64,
    Copysignf128,
    Copysignf32x,
    Copysignf64x,
    Copysignf128x,
    Cos,
    Cosf,
    Cosh,
    Coshf,
    Coshl,
    Cosl,
    Drem,
    Dremf,
    Dreml,
    Erf,
    Erfc,
    Erfcf,
    Erfcl,
    Erff,
    Erfl,
    Exp,
    Exp10,
    Exp10f,
    Exp10l,
    Exp2,
    Exp2f,
    Exp2l,
    Expf,
    Expl,
    Expm1,
    Expm1f,
    Expm1l,
    Fabs,
    Fabsf,
    Fabsl,
    Fabsf16,
    Fabsf32,
    Fabsf64,
    Fabsf128,
    Fabsf32x,
    Fabsf64x,
    Fabsf128x,
    Fabsd32,
    Fabsd64,
    Fabsd128,
    Fdim,
    Fdimf,
    Fdiml,
    Feclearexcept,
    Fegetenv,
    Fegetexceptflag,
    Fegetround,
    Feholdexcept,
    Feraiseexcept,
    Fesetenv,
    Fesetexceptflag,
    Fesetround,
    Fetestexcept,
    Feupdateenv,
    Floor,
    Floorf,
    Floorl,
    Floorf16,
    Floorf32,
    Floorf64,
    Floorf128,
    Floorf32x,
    Floorf64x,
    Floorf128x,
    Fma,
    Fmaf,
    Fmal,
    Fmaf16,
    Fmaf32,
    Fmaf64,
    Fmaf128,
    Fmaf32x,
    Fmaf64x,
    Fmaf128x,
    Fmax,
    Fmaxf,
    Fmaxl,
    Fmaxf16,
    Fmaxf32,
    Fmaxf64,
    Fmaxf128,
    Fmaxf32x,
    Fmaxf64x,
    Fmaxf128x,
    Fmin,
    Fminf,
    Fminl,
    Fminf16,
    Fminf32,
    Fminf64,
    Fminf128,
    Fminf32x,
    Fminf64x,
    Fminf128x,
    Fmod,
    Fmodf,
    Fmodl,
    Frexp,
    Frexpf,
    Frexpl,
    Gamma,
    Gammaf,
    Gammal,
    GammaR,
    GammafR,
    GammalR,
    HugeVal,
    HugeValf,
    HugeVall,
    HugeValf16,
    HugeValf32,
    HugeValf64,
    HugeValf128,
    HugeValf32x,
    HugeValf64x,
    HugeValf128x,
    Hypot,
    Hypotf,
    Hypotl,
    Iceil,
    Iceilf,
    Iceill,
    Ifloor,
    Ifloorf,
    Ifloorl,
    Ilogb,
    Ilogbf,
    Ilogbl,
    Inf,
    Inff,
    Infl,
    Inff16,
    Inff32,
    Inff64,
    Inff128,
    Inff32x,
    Inff64x,
    Inff128x,
    Infd32,
    Infd64,
    Infd128,
    Irint,
    Irintf,
    Irintl,
    Iround,
    Iroundf,
    Iroundl,
    J0,
    J0f,
    J0l,
    J1,
    J1f,
    J1l,
    Jn,
    Jnf,
    Jnl,
    Lceil,
    Lceilf,
    Lceill,
    Ldexp,
    Ldexpf,
    Ldexpl,
    Lfloor,
    Lfloorf,
    Lfloorl,
    Lgamma,
    Lgammaf,
    Lgammal,
    LgammaR,
    LgammafR,
    LgammalR,
    Llceil,
    Llceilf,
    Llceill,
    Llfloor,
    Llfloorf,
    Llfloorl,
    Llrint,
    Llrintf,
    Llrintl,
    Llround,
    Llroundf,
    Llroundl,
    Log,
    Log10,
    Log10f,
    Log10l,
    Log1p,
    Log1pf,
    Log1pl,
    Log2,
    Log2f,
    Log2l,
    Logb,
    Logbf,
    Logbl,
    Logf,
    Logl,
    Lrint,
    Lrintf,
    Lrintl,
    Lround,
    Lroundf,
    Lroundl,
    Modf,
    Modff,
    Modfl,
    Nan,
    Nanf,
    Nanl,
    Nanf16,
    Nanf32,
    Nanf64,
    Nanf128,
    Nanf32x,
    Nanf64x,
    Nanf128x,
    Nand32,
    Nand64,
    Nand128,
    Nans,
    Nansf,
    Nansl,
    Nansf16,
    Nansf32,
    Nansf64,
    Nansf128,
    Nansf32x,
    Nansf64x,
    Nansf128x,
    Nearbyint,
    Nearbyintf,
    Nearbyintl,
    Nearbyintf16,
    Nearbyintf32,
    Nearbyintf64,
    Nearbyintf128,
    Nearbyintf32x,
    Nearbyintf64x,
    Nearbyintf128x,
    Nextafter,
    Nextafterf,
    Nextafterl,
    Nexttoward,
    Nexttowardf,
    Nexttowardl,
    Pow,
    Pow10,
    Pow10f,
    Pow10l,
    Powf,
    Powi,
    Powif,
    Powil,
    Powl,
    Remainder,
    Remainderf,
    Remainderl,
    Remquo,
    Remquof,
    Remquol,
    Rint,
    Rintf,
    Rintl,
    Rintf16,
    Rintf32,
    Rintf64,
    Rintf128,
    Rintf32x,
    Rintf64x,
    Rintf128x,
    Roundeven,
    Roundevenf,
    Roundevenl,
    Round,
    Roundf,
    Roundl,
    Roundf16,
    Roundf32,
    Roundf64,
    Roundf128,
    Roundf32x,
    Roundf64x,
    Roundf128x,
    Roundevenf16,
    Roundevenf32,
    Roundevenf64,
    Roundevenf128,
    Roundevenf32x,
    Roundevenf64x,
    Roundevenf128x,
    Scalb,
    Scalbf,
    Scalbl,
    Scalbln,
    Scalblnf,
    Scalblnl,
    Scalbn,
    Scalbnf,
    Scalbnl,
    Signbit,
    Signbitf,
    Signbitl,
    Signbitd32,
    Signbitd64,
    Signbitd128,
    Significand,
    Significandf,
    Significandl,
    Sin,
    Sincos,
    Sincosf,
    Sincosl,
    Sinf,
    Sinh,
    Sinhf,
    Sinhl,
    Sinl,
    Sqrt,
    Sqrtf,
    Sqrtl,
    Sqrtf16,
    Sqrtf32,
    Sqrtf64,
    Sqrtf128,
    Sqrtf32x,
    Sqrtf64x,
    Sqrtf128x,
    Tan,
    Tanf,
    Tanh,
    Tanhf,
    Tanhl,
    Tanl,
    Tgamma,
    Tgammaf,
    Tgammal,
    Trunc,
    Truncf,
    Truncl,
    Truncf16,
    Truncf32,
    Truncf64,
    Truncf128,
    Truncf32x,
    Truncf64x,
    Truncf128x,
    Y0,
    Y0f,
    Y0l,
    Y1,
    Y1f,
    Y1l,
    Yn,
    Ynf,
    Ynl,
    Cabs,
    Cabsf,
    Cabsl,
    Cacos,
    Cacosf,
    Cacosh,
    Cacoshf,
    Cacoshl,
    Cacosl,
    Carg,
    Cargf,
    Cargl,
    Casin,
    Casinf,
    Casinh,
    Casinhf,
    Casinhl,
    Casinl,
    Catan,
    Catanf,
    Catanh,
    Catanhf,
    Catanhl,
    Catanl,
    Ccos,
    Ccosf,
    Ccosh,
    Ccoshf,
    Ccoshl,
    Ccosl,
    Cexp,
    Cexpf,
    Cexpl,
    Cexpi,
    Cexpif,
    Cexpil,
    Cimag,
    Cimagf,
    Cimagl,
    Clog,
    Clogf,
    Clogl,
    Clog10,
    Clog10f,
    Clog10l,
    Conj,
    Conjf,
    Conjl,
    Cpow,
    Cpowf,
    Cpowl,
    Cproj,
    Cprojf,
    Cprojl,
    Creal,
    Crealf,
    Creall,
    Csin,
    Csinf,
    Csinh,
    Csinhf,
    Csinhl,
    Csinl,
    Csqrt,
    Csqrtf,
    Csqrtl,
    Ctan,
    Ctanf,
    Ctanh,
    Ctanhf,
    Ctanhl,
    Ctanl,
    Bcmp,
    Bcopy,
    Bzero,
    Index,
    Memchr,
    Memcmp,
    Memcpy,
    Memmove,
    Mempcpy,
    Memset,
    Rindex,
    Stpcpy,
    Stpncpy,
    Strcasecmp,
    Strcat,
    Strchr,
    Strcmp,
    Strcpy,
    Strcspn,
    Strdup,
    Strndup,
    Strlen,
    Strncasecmp,
    Strncat,
    Strncmp,
    Strncpy,
    Strnlen,
    Strpbrk,
    Strrchr,
    Strspn,
    Strstr,
    Fprintf,
    FprintfUnlocked,
    Putc,
    PutcUnlocked,
    Fputc,
    FputcUnlocked,
    Fputs,
    FputsUnlocked,
    Fscanf,
    Fwrite,
    FwriteUnlocked,
    Printf,
    PrintfUnlocked,
    Putchar,
    PutcharUnlocked,
    Puts,
    PutsUnlocked,
    Scanf,
    Snprintf,
    Sprintf,
    Sscanf,
    Vfprintf,
    Vfscanf,
    Vprintf,
    Vscanf,
    Vsnprintf,
    Vsprintf,
    Vsscanf,
    Isalnum,
    Isalpha,
    Isascii,
    Isblank,
    Iscntrl,
    Isdigit,
    Isgraph,
    Islower,
    Isprint,
    Ispunct,
    Isspace,
    Isupper,
    Isxdigit,
    Toascii,
    Tolower,
    Toupper,
    Iswalnum,
    Iswalpha,
    Iswblank,
    Iswcntrl,
    Iswdigit,
    Iswgraph,
    Iswlower,
    Iswprint,
    Iswpunct,
    Iswspace,
    Iswupper,
    Iswxdigit,
    Towlower,
    Towupper,
    AddOverflow,
    SubOverflow,
    MulOverflow,
    AddOverflowP,
    SubOverflowP,
    MulOverflowP,
    SaddOverflow,
    SaddlOverflow,
    SaddllOverflow,
    SsubOverflow,
    SsublOverflow,
    SsubllOverflow,
    SmulOverflow,
    SmullOverflow,
    SmulllOverflow,
    UaddOverflow,
    UaddlOverflow,
    UaddllOverflow,
    UsubOverflow,
    UsublOverflow,
    UsubllOverflow,
    UmulOverflow,
    UmullOverflow,
    UmulllOverflow,
    Abort,
    Abs,
    AggregateIncomingAddress,
    Alloca,
    Apply,
    ApplyArgs,
    Bswap16,
    Bswap32,
    Bswap64,
    ClearCache,
    Calloc,
    ClassifyType,
    Clz,
    Clzimax,
    Clzl,
    Clzll,
    ConstantP,
    Ctz,
    Ctzimax,
    Ctzl,
    Ctzll,
    Clrsb,
    Clrsbimax,
    Clrsbl,
    Clrsbll,
    Dcgettext,
    Dgettext,
    DwarfCfa,
    DwarfSpColumn,
    EhReturn,
    EhReturnDataRegno,
    Execl,
    Execlp,
    Execle,
    Execv,
    Execvp,
    Execve,
    Exit,
    Expect,
    ExpectWithProbability,
    AssumeAligned,
    ExtendPointer,
    ExtractReturnAddr,
    Ffs,
    Ffsimax,
    Ffsl,
    Ffsll,
    Fork,
    FrameAddress,
    Free,
    FrobReturnAddr,
    Gettext,
    Imaxabs,
    InitDwarfRegSizes,
    Finite,
    Finitef,
    Finitel,
    Finited32,
    Finited64,
    Finited128,
    Fpclassify,
    Isfinite,
    IsinfSign,
    Isinf,
    Isinff,
    Isinfl,
    Isinfd32,
    Isinfd64,
    Isinfd128,
    Isnan,
    Isnanf,
    Isnanl,
    Isnand32,
    Isnand64,
    Isnand128,
    Isnormal,
    Isgreater,
    Isgreaterequal,
    Isless,
    Islessequal,
    Islessgreater,
    Isunordered,
    Labs,
    Llabs,
    Longjmp,
    Malloc,
    NextArg,
    Parity,
    Parityimax,
    Parityl,
    Parityll,
    Popcount,
    Popcountimax,
    Popcountl,
    Popcountll,
    PosixMemalign,
    Prefetch,
    Realloc,
    Return,
    ReturnAddress,
    Saveregs,
    Setjmp,
    Strfmon,
    Strftime,
    Trap,
    Unreachable,
    UnwindInit,
    UpdateSetjmpBuf,
    VaCopy,
    VaEnd,
    VaStart,
    VaArgPack,
    VaArgPackLen,
    _Exit,
    _Exit2,
    InitTrampoline,
    InitHeapTrampoline,
    AdjustTrampoline,
    InitDescriptor,
    AdjustDescriptor,
    NonlocalGoto,
    SetjmpSetup,
    SetjmpReceiver,
    StackSave,
    StackRestore,
    AllocaWithAlign,
    AllocaWithAlignAndMax,
    MemcmpEq,
    StrcmpEq,
    StrncmpEq,
    ObjectSize,
    MemcpyChk,
    MemmoveChk,
    MempcpyChk,
    MemsetChk,
    StpcpyChk,
    StpncpyChk,
    StrcatChk,
    StrcpyChk,
    StrncatChk,
    StrncpyChk,
    SnprintfChk,
    SprintfChk,
    VsnprintfChk,
    VsprintfChk,
    FprintfChk,
    PrintfChk,
    VfprintfChk,
    VprintfChk,
    ProfileFuncEnter,
    ProfileFuncExit,
    ThreadPointer,
    SetThreadPointer,
    EmutlsGetAddress,
    EmutlsRegisterCommon,
    SpeculationSafeValueN,
    SpeculationSafeValuePtr,
    SpeculationSafeValue1,
    SpeculationSafeValue2,
    SpeculationSafeValue4,
    SpeculationSafeValue8,
    SpeculationSafeValue16,
    UnwindResume,
    CxaEndCleanup,
    EhPointer,
    EhFilter,
    EhCopyValues,
    File,
    Function,
    Line,
    SyncFetchAndAddN,
    SyncFetchAndAdd1,
    SyncFetchAndAdd2,
    SyncFetchAndAdd4,
    SyncFetchAndAdd8,
    SyncFetchAndAdd16,
    SyncFetchAndSubN,
    SyncFetchAndSub1,
    SyncFetchAndSub2,
    SyncFetchAndSub4,
    SyncFetchAndSub8,
    SyncFetchAndSub16,
    SyncFetchAndOrN,
    SyncFetchAndOr1,
    SyncFetchAndOr2,
    SyncFetchAndOr4,
    SyncFetchAndOr8,
    SyncFetchAndOr16,
    SyncFetchAndAndN,
    SyncFetchAndAnd1,
    SyncFetchAndAnd2,
    SyncFetchAndAnd4,
    SyncFetchAndAnd8,
    SyncFetchAndAnd16,
    SyncFetchAndXorN,
    SyncFetchAndXor1,
    SyncFetchAndXor2,
    SyncFetchAndXor4,
    SyncFetchAndXor8,
    SyncFetchAndXor16,
    SyncFetchAndNandN,
    SyncFetchAndNand1,
    SyncFetchAndNand2,
    SyncFetchAndNand4,
    SyncFetchAndNand8,
    SyncFetchAndNand16,
    SyncAddAndFetchN,
    SyncAddAndFetch1,
    SyncAddAndFetch2,
    SyncAddAndFetch4,
    SyncAddAndFetch8,
    SyncAddAndFetch16,
    SyncSubAndFetchN,
    SyncSubAndFetch1,
    SyncSubAndFetch2,
    SyncSubAndFetch4,
    SyncSubAndFetch8,
    SyncSubAndFetch16,
    SyncOrAndFetchN,
    SyncOrAndFetch1,
    SyncOrAndFetch2,
    SyncOrAndFetch4,
    SyncOrAndFetch8,
    SyncOrAndFetch16,
    SyncAndAndFetchN,
    SyncAndAndFetch1,
    SyncAndAndFetch2,
    SyncAndAndFetch4,
    SyncAndAndFetch8,
    SyncAndAndFetch16,
    SyncXorAndFetchN,
    SyncXorAndFetch1,
    SyncXorAndFetch2,
    SyncXorAndFetch4,
    SyncXorAndFetch8,
    SyncXorAndFetch16,
    SyncNandAndFetchN,
    SyncNandAndFetch1,
    SyncNandAndFetch2,
    SyncNandAndFetch4,
    SyncNandAndFetch8,
    SyncNandAndFetch16,
    SyncBoolCompareAndSwapN,
    SyncBoolCompareAndSwap1,
    SyncBoolCompareAndSwap2,
    SyncBoolCompareAndSwap4,
    SyncBoolCompareAndSwap8,
    SyncBoolCompareAndSwap16,
    SyncValCompareAndSwapN,
    SyncValCompareAndSwap1,
    SyncValCompareAndSwap2,
    SyncValCompareAndSwap4,
    SyncValCompareAndSwap8,
    SyncValCompareAndSwap16,
    SyncLockTestAndSetN,
    SyncLockTestAndSet1,
    SyncLockTestAndSet2,
    SyncLockTestAndSet4,
    SyncLockTestAndSet8,
    SyncLockTestAndSet16,
    SyncLockReleaseN,
    SyncLockRelease1,
    SyncLockRelease2,
    SyncLockRelease4,
    SyncLockRelease8,
    SyncLockRelease16,
    SyncSynchronize,
    AtomicTestAndSet,
    AtomicClear,
    AtomicExchange,
    AtomicExchangeN,
    AtomicExchange1,
    AtomicExchange2,
    AtomicExchange4,
    AtomicExchange8,
    AtomicExchange16,
    AtomicLoad,
    AtomicLoadN,
    AtomicLoad1,
    AtomicLoad2,
    AtomicLoad4,
    AtomicLoad8,
    AtomicLoad16,
    AtomicCompareExchange,
    AtomicCompareExchangeN,
    AtomicCompareExchange1,
    AtomicCompareExchange2,
    AtomicCompareExchange4,
    AtomicCompareExchange8,
    AtomicCompareExchange16,
    AtomicStore,
    AtomicStoreN,
    AtomicStore1,
    AtomicStore2,
    AtomicStore4,
    AtomicStore8,
    AtomicStore16,
    AtomicAddFetchN,
    AtomicAddFetch1,
    AtomicAddFetch2,
    AtomicAddFetch4,
    AtomicAddFetch8,
    AtomicAddFetch16,
    AtomicSubFetchN,
    AtomicSubFetch1,
    AtomicSubFetch2,
    AtomicSubFetch4,
    AtomicSubFetch8,
    AtomicSubFetch16,
    AtomicAndFetchN,
    AtomicAndFetch1,
    AtomicAndFetch2,
    AtomicAndFetch4,
    AtomicAndFetch8,
    AtomicAndFetch16,
    AtomicNandFetchN,
    AtomicNandFetch1,
    AtomicNandFetch2,
    AtomicNandFetch4,
    AtomicNandFetch8,
    AtomicNandFetch16,
    AtomicXorFetchN,
    AtomicXorFetch1,
    AtomicXorFetch2,
    AtomicXorFetch4,
    AtomicXorFetch8,
    AtomicXorFetch16,
    AtomicOrFetchN,
    AtomicOrFetch1,
    AtomicOrFetch2,
    AtomicOrFetch4,
    AtomicOrFetch8,
    AtomicOrFetch16,
    AtomicFetchAddN,
    AtomicFetchAdd1,
    AtomicFetchAdd2,
    AtomicFetchAdd4,
    AtomicFetchAdd8,
    AtomicFetchAdd16,
    AtomicFetchSubN,
    AtomicFetchSub1,
    AtomicFetchSub2,
    AtomicFetchSub4,
    AtomicFetchSub8,
    AtomicFetchSub16,
    AtomicFetchAndN,
    AtomicFetchAnd1,
    AtomicFetchAnd2,
    AtomicFetchAnd4,
    AtomicFetchAnd8,
    AtomicFetchAnd16,
    AtomicFetchNandN,
    AtomicFetchNand1,
    AtomicFetchNand2,
    AtomicFetchNand4,
    AtomicFetchNand8,
    AtomicFetchNand16,
    AtomicFetchXorN,
    AtomicFetchXor1,
    AtomicFetchXor2,
    AtomicFetchXor4,
    AtomicFetchXor8,
    AtomicFetchXor16,
    AtomicFetchOrN,
    AtomicFetchOr1,
    AtomicFetchOr2,
    AtomicFetchOr4,
    AtomicFetchOr8,
    AtomicFetchOr16,
    AtomicAlwaysLockFree,
    AtomicIsLockFree,
    AtomicThreadFence,
    AtomicSignalFence,
    AtomicFeraiseexcept,
    AccGetDeviceType,
    GoaccDataStart,
    GoaccDataEnd,
    GoaccEnterExitData,
    GoaccParallel,
    GoaccUpdate,
    GoaccWait,
    AccOnDevice,
    GoaccParlevelId,
    GoaccParlevelSize,
    OmpGetThreadNum,
    OmpGetNumThreads,
    OmpGetTeamNum,
    OmpGetNumTeams,
    GompAtomicStart,
    GompAtomicEnd,
    GompBarrier,
    GompBarrierCancel,
    GompTaskwait,
    GompTaskwaitDepend,
    GompTaskyield,
    GompTaskgroupStart,
    GompTaskgroupEnd,
    GompCancel,
    GompCancellationPoint,
    GompCriticalStart,
    GompCriticalEnd,
    GompCriticalNameStart,
    GompCriticalNameEnd,
    GompLoopStaticStart,
    GompLoopDynamicStart,
    GompLoopGuidedStart,
    GompLoopRuntimeStart,
    GompLoopNonmonotonicDynamicStart,
    GompLoopNonmonotonicGuidedStart,
    GompLoopNonmonotonicRuntimeStart,
    GompLoopMaybeNonmonotonicRuntimeStart,
    GompLoopOrderedStaticStart,
    GompLoopOrderedDynamicStart,
    GompLoopOrderedGuidedStart,
    GompLoopOrderedRuntimeStart,
    GompLoopDoacrossStaticStart,
    GompLoopDoacrossDynamicStart,
    GompLoopDoacrossGuidedStart,
    GompLoopDoacrossRuntimeStart,
    GompLoopStart,
    GompLoopOrderedStart,
    GompLoopDoacrossStart,
    GompLoopStaticNext,
    GompLoopDynamicNext,
    GompLoopGuidedNext,
    GompLoopRuntimeNext,
    GompLoopNonmonotonicDynamicNext,
    GompLoopNonmonotonicGuidedNext,
    GompLoopNonmonotonicRuntimeNext,
    GompLoopMaybeNonmonotonicRuntimeNext,
    GompLoopOrderedStaticNext,
    GompLoopOrderedDynamicNext,
    GompLoopOrderedGuidedNext,
    GompLoopOrderedRuntimeNext,
    GompLoopUllStaticStart,
    GompLoopUllDynamicStart,
    GompLoopUllGuidedStart,
    GompLoopUllRuntimeStart,
    GompLoopUllNonmonotonicDynamicStart,
    GompLoopUllNonmonotonicGuidedStart,
    GompLoopUllNonmonotonicRuntimeStart,
    GompLoopUllMaybeNonmonotonicRuntimeStart,
    GompLoopUllOrderedStaticStart,
    GompLoopUllOrderedDynamicStart,
    GompLoopUllOrderedGuidedStart,
    GompLoopUllOrderedRuntimeStart,
    GompLoopUllDoacrossStaticStart,
    GompLoopUllDoacrossDynamicStart,
    GompLoopUllDoacrossGuidedStart,
    GompLoopUllDoacrossRuntimeStart,
    GompLoopUllStart,
    GompLoopUllOrderedStart,
    GompLoopUllDoacrossStart,
    GompLoopUllStaticNext,
    GompLoopUllDynamicNext,
    GompLoopUllGuidedNext,
    GompLoopUllRuntimeNext,
    GompLoopUllNonmonotonicDynamicNext,
    GompLoopUllNonmonotonicGuidedNext,
    GompLoopUllNonmonotonicRuntimeNext,
    GompLoopUllMaybeNonmonotonicRuntimeNext,
    GompLoopUllOrderedStaticNext,
    GompLoopUllOrderedDynamicNext,
    GompLoopUllOrderedGuidedNext,
    GompLoopUllOrderedRuntimeNext,
    GompParallelLoopStatic,
    GompParallelLoopDynamic,
    GompParallelLoopGuided,
    GompParallelLoopRuntime,
    GompParallelLoopNonmonotonicDynamic,
    GompParallelLoopNonmonotonicGuided,
    GompParallelLoopNonmonotonicRuntime,
    GompParallelLoopMaybeNonmonotonicRuntime,
    GompLoopEnd,
    GompLoopEndCancel,
    GompLoopEndNowait,
    GompOrderedStart,
    GompOrderedEnd,
    GompDoacrossPost,
    GompDoacrossWait,
    GompDoacrossUllPost,
    GompDoacrossUllWait,
    GompParallel,
    GompParallelReductions,
    GompTask,
    GompTaskloop,
    GompTaskloopUll,
    GompSectionsStart,
    GompSections2Start,
    GompSectionsNext,
    GompParallelSections,
    GompSectionsEnd,
    GompSectionsEndCancel,
    GompSectionsEndNowait,
    GompSingleStart,
    GompSingleCopyStart,
    GompSingleCopyEnd,
    GompOffloadRegister,
    GompOffloadUnregister,
    GompTarget,
    GompTargetData,
    GompTargetEndData,
    GompTargetUpdate,
    GompTargetEnterExitData,
    GompTeams,
    GompTeamsReg,
    GompTaskgroupReductionRegister,
    GompTaskgroupReductionUnregister,
    GompTaskReductionRemap,
    GompWorkshareTaskReductionUnregister,
    GoaccDeclare,
    HsaWorkgroupid,
    HsaWorkitemid,
    HsaWorkitemabsid,
    HsaGridsize,
    HsaCurrentworkgroupsize,
    TmStart,
    TmCommit,
    TmCommitEh,
    TmAbort,
    TmIrrevocable,
    TmMemcpy,
    TmMemcpyRnwt,
    TmMemcpyRtwn,
    TmMemmove,
    TmMemset,
    TmGettmcloneIrr,
    TmGettmcloneSafe,
    TmMalloc,
    TmCalloc,
    TmFree,
    TmLog1,
    TmLog2,
    TmLog4,
    TmLog8,
    TmLogFloat,
    TmLogDouble,
    TmLogLdouble,
    TmLog,
    TmLogM64,
    TmLogM128,
    TmLogM256,
    TmStore1,
    TmStoreWar1,
    TmStoreWaw1,
    TmStore2,
    TmStoreWar2,
    TmStoreWaw2,
    TmStore4,
    TmStoreWar4,
    TmStoreWaw4,
    TmStore8,
    TmStoreWar8,
    TmStoreWaw8,
    TmStoreFloat,
    TmStoreWarFloat,
    TmStoreWawFloat,
    TmStoreDouble,
    TmStoreWarDouble,
    TmStoreWawDouble,
    TmStoreM64,
    TmStoreWarM64,
    TmStoreWawM64,
    TmStoreM128,
    TmStoreWarM128,
    TmStoreWawM128,
    TmStoreM256,
    TmStoreWarM256,
    TmStoreWawM256,
    TmStoreLdouble,
    TmStoreWarLdouble,
    TmStoreWawLdouble,
    TmLoad1,
    TmLoadRar1,
    TmLoadRaw1,
    TmLoadRfw1,
    TmLoad2,
    TmLoadRar2,
    TmLoadRaw2,
    TmLoadRfw2,
    TmLoad4,
    TmLoadRar4,
    TmLoadRaw4,
    TmLoadRfw4,
    TmLoad8,
    TmLoadRar8,
    TmLoadRaw8,
    TmLoadRfw8,
    TmLoadFloat,
    TmLoadRarFloat,
    TmLoadRawFloat,
    TmLoadRfwFloat,
    TmLoadDouble,
    TmLoadRarDouble,
    TmLoadRawDouble,
    TmLoadRfwDouble,
    TmLoadM64,
    TmLoadRarM64,
    TmLoadRawM64,
    TmLoadRfwM64,
    TmLoadM128,
    TmLoadRarM128,
    TmLoadRawM128,
    TmLoadRfwM128,
    TmLoadM256,
    TmLoadRarM256,
    TmLoadRawM256,
    TmLoadRfwM256,
    TmLoadLdouble,
    TmLoadRarLdouble,
    TmLoadRawLdouble,
    TmLoadRfwLdouble,
    BeginSanitizerBuiltins,
    AsanInit,
    AsanVersionMismatchCheck,
    AsanReportLoad1,
    AsanReportLoad2,
    AsanReportLoad4,
    AsanReportLoad8,
    AsanReportLoad16,
    AsanReportLoadN,
    AsanReportStore1,
    AsanReportStore2,
    AsanReportStore4,
    AsanReportStore8,
    AsanReportStore16,
    AsanReportStoreN,
    AsanReportLoad1Noabort,
    AsanReportLoad2Noabort,
    AsanReportLoad4Noabort,
    AsanReportLoad8Noabort,
    AsanReportLoad16Noabort,
    AsanReportLoadNNoabort,
    AsanReportStore1Noabort,
    AsanReportStore2Noabort,
    AsanReportStore4Noabort,
    AsanReportStore8Noabort,
    AsanReportStore16Noabort,
    AsanReportStoreNNoabort,
    AsanLoad1,
    AsanLoad2,
    AsanLoad4,
    AsanLoad8,
    AsanLoad16,
    AsanLoadn,
    AsanStore1,
    AsanStore2,
    AsanStore4,
    AsanStore8,
    AsanStore16,
    AsanStoren,
    AsanLoad1Noabort,
    AsanLoad2Noabort,
    AsanLoad4Noabort,
    AsanLoad8Noabort,
    AsanLoad16Noabort,
    AsanLoadnNoabort,
    AsanStore1Noabort,
    AsanStore2Noabort,
    AsanStore4Noabort,
    AsanStore8Noabort,
    AsanStore16Noabort,
    AsanStorenNoabort,
    AsanRegisterGlobals,
    AsanUnregisterGlobals,
    AsanHandleNoReturn,
    AsanBeforeDynamicInit,
    AsanAfterDynamicInit,
    AsanPoisonStackMemory,
    AsanUnpoisonStackMemory,
    AsanAllocaPoison,
    AsanAllocasUnpoison,
    AsanPointerCompare,
    AsanPointerSubtract,
    TsanInit,
    TsanFuncEntry,
    TsanFuncExit,
    TsanVptrUpdate,
    TsanRead1,
    TsanRead2,
    TsanRead4,
    TsanRead8,
    TsanRead16,
    TsanWrite1,
    TsanWrite2,
    TsanWrite4,
    TsanWrite8,
    TsanWrite16,
    TsanReadRange,
    TsanWriteRange,
    TsanAtomic8Load,
    TsanAtomic16Load,
    TsanAtomic32Load,
    TsanAtomic64Load,
    TsanAtomic128Load,
    TsanAtomic8Store,
    TsanAtomic16Store,
    TsanAtomic32Store,
    TsanAtomic64Store,
    TsanAtomic128Store,
    TsanAtomic8Exchange,
    TsanAtomic16Exchange,
    TsanAtomic32Exchange,
    TsanAtomic64Exchange,
    TsanAtomic128Exchange,
    TsanAtomic8FetchAdd,
    TsanAtomic16FetchAdd,
    TsanAtomic32FetchAdd,
    TsanAtomic64FetchAdd,
    TsanAtomic128FetchAdd,
    TsanAtomic8FetchSub,
    TsanAtomic16FetchSub,
    TsanAtomic32FetchSub,
    TsanAtomic64FetchSub,
    TsanAtomic128FetchSub,
    TsanAtomic8FetchAnd,
    TsanAtomic16FetchAnd,
    TsanAtomic32FetchAnd,
    TsanAtomic64FetchAnd,
    TsanAtomic128FetchAnd,
    TsanAtomic8FetchOr,
    TsanAtomic16FetchOr,
    TsanAtomic32FetchOr,
    TsanAtomic64FetchOr,
    TsanAtomic128FetchOr,
    TsanAtomic8FetchXor,
    TsanAtomic16FetchXor,
    TsanAtomic32FetchXor,
    TsanAtomic64FetchXor,
    TsanAtomic128FetchXor,
    TsanAtomic8FetchNand,
    TsanAtomic16FetchNand,
    TsanAtomic32FetchNand,
    TsanAtomic64FetchNand,
    TsanAtomic128FetchNand,
    TsanAtomic8CompareExchangeStrong,
    TsanAtomic16CompareExchangeStrong,
    TsanAtomic32CompareExchangeStrong,
    TsanAtomic64CompareExchangeStrong,
    TsanAtomic128CompareExchangeStrong,
    TsanAtomic8CompareExchangeWeak,
    TsanAtomic16CompareExchangeWeak,
    TsanAtomic32CompareExchangeWeak,
    TsanAtomic64CompareExchangeWeak,
    TsanAtomic128CompareExchangeWeak,
    TsanAtomicThreadFence,
    TsanAtomicSignalFence,
    UbsanHandleDivremOverflow,
    UbsanHandleShiftOutOfBounds,
    UbsanHandleBuiltinUnreachable,
    UbsanHandleMissingReturn,
    UbsanHandleVlaBoundNotPositive,
    UbsanHandleTypeMismatchV1,
    UbsanHandleAddOverflow,
    UbsanHandleSubOverflow,
    UbsanHandleMulOverflow,
    UbsanHandleNegateOverflow,
    UbsanHandleLoadInvalidValue,
    UbsanHandlePointerOverflow,
    UbsanHandleDivremOverflowAbort,
    UbsanHandleShiftOutOfBoundsAbort,
    UbsanHandleVlaBoundNotPositiveAbort,
    UbsanHandleTypeMismatchV1Abort,
    UbsanHandleAddOverflowAbort,
    UbsanHandleSubOverflowAbort,
    UbsanHandleMulOverflowAbort,
    UbsanHandleNegateOverflowAbort,
    UbsanHandleLoadInvalidValueAbort,
    UbsanHandlePointerOverflowAbort,
    UbsanHandleFloatCastOverflow,
    UbsanHandleFloatCastOverflowAbort,
    UbsanHandleOutOfBounds,
    UbsanHandleOutOfBoundsAbort,
    UbsanHandleNonnullArg,
    UbsanHandleNonnullArgAbort,
    UbsanHandleNonnullReturnV1,
    UbsanHandleNonnullReturnV1Abort,
    UbsanHandleInvalidBuiltin,
    UbsanHandleInvalidBuiltinAbort,
    UbsanHandleDynamicTypeCacheMiss,
    UbsanHandleDynamicTypeCacheMissAbort,
    SanitizerCovTracePc,
    SanitizerCovTraceCmp1,
    SanitizerCovTraceCmp2,
    SanitizerCovTraceCmp4,
    SanitizerCovTraceCmp8,
    SanitizerCovTraceConstCmp1,
    SanitizerCovTraceConstCmp2,
    SanitizerCovTraceConstCmp4,
    SanitizerCovTraceConstCmp8,
    SanitizerCovTraceCmpf,
    SanitizerCovTraceCmpd,
    SanitizerCovTraceSwitch,
    EndSanitizerBuiltins,
    HsailWorkitemabsid,
    HsailGridsize,
    HsailWorkitemflatabsidU32,
    HsailWorkitemflatabsidU64,
    HsailWorkitemflatid,
    HsailWorkitemid,
    HsailWorkgroupid,
    HsailCurrentworkitemflatid,
    HsailWorkitemabsidU64,
    HsailPacketid,
    HsailPacketcompletionsigSig64,
    HsailPacketcompletionsigSig32,
    HsailCurrentworkgroupsize,
    HsailWorkgroupsize,
    HsailDim,
    HsailGridgroups,
    HsailBitextractS32,
    HsailBitextractU32,
    HsailBitextractS64,
    HsailBitextractU64,
    HsailBitinsertU32,
    HsailBitinsertU64,
    HsailBitmaskB32,
    HsailBitmaskB64,
    HsailBitrevB32,
    HsailBitrevB64,
    HsailBitselectB32,
    HsailBitselectU64,
    HsailFirstbitU32,
    HsailFirstbitS32,
    HsailFirstbitU64,
    HsailFirstbitS64,
    HsailLastbitU32,
    HsailLastbitU64,
    HsailBorrowU32,
    HsailBorrowU64,
    HsailCarryU32,
    HsailCarryU64,
    HsailRemS32,
    HsailRemS64,
    HsailMinF32,
    HsailMaxF32,
    HsailMinF64,
    HsailMaxF64,
    HsailClassF32,
    HsailClassF64,
    HsailClassF32F16,
    HsailFractF32,
    HsailFractF64,
    HsailBarrier,
    HsailInitfbar,
    HsailJoinfbar,
    HsailWaitfbar,
    HsailArrivefbar,
    HsailLeavefbar,
    HsailReleasefbar,
    HsailBitalign,
    HsailBytealign,
    HsailLerp,
    HsailPackcvt,
    HsailUnpackcvt,
    HsailSadU16x2,
    HsailSadU32,
    HsailSadU8x4,
    HsailSadhiU8x4,
    HsailClock,
    HsailCuid,
    HsailMaxcuid,
    HsailDebugtrap,
    HsailGroupbaseptr,
    HsailKernargbaseptrU64,
    HsailKernargbaseptrU32,
    HsailAlloca,
    HsailLdqueuewriteindex,
    HsailLdqueuereadindex,
    HsailStqueuewriteindex,
    HsailStqueuereadindex,
    HsailAddqueuewriteindex,
    HsailCasqueuewriteindex,
    HsailSegmentpGlobal,
    HsailSegmentpGroup,
    HsailSegmentpPrivate,
    HsailAtomicMinS32,
    HsailAtomicMinS64,
    HsailAtomicMinU32,
    HsailAtomicMinU64,
    HsailAtomicMaxS32,
    HsailAtomicMaxS64,
    HsailAtomicMaxU32,
    HsailAtomicMaxU64,
    HsailAtomicWrapdecU32,
    HsailAtomicWrapdecU64,
    HsailAtomicWrapincU32,
    HsailAtomicWrapincU64,
    HsailSatAddU64,
    HsailSatAddS64,
    HsailSatAddU32,
    HsailSatAddS32,
    HsailSatAddU16,
    HsailSatAddS16,
    HsailSatAddU8,
    HsailSatAddS8,
    HsailSatSubU64,
    HsailSatSubS64,
    HsailSatSubU32,
    HsailSatSubS32,
    HsailSatSubU16,
    HsailSatSubS16,
    HsailSatSubU8,
    HsailSatSubS8,
    HsailSatMulU64,
    HsailSatMulS64,
    HsailSatMulU32,
    HsailSatMulS32,
    HsailSatMulU16,
    HsailSatMulS16,
    HsailSatMulU8,
    HsailSatMulS8,
    HsailFtzF32F16,
    HsailFtzF32,
    HsailFtzF64,
    HsailPushFrame,
    HsailPopFrame,
    HsailSetworkitemid,
    HsailLaunchWgFunc,
    HsailLaunchKernel,
    HsailF32ToF16,
    HsailF16ToF32,
    HsailCvtZeroiSatU8F32,
    HsailCvtZeroiSatS8F32,
    HsailCvtZeroiSatU16F32,
    HsailCvtZeroiSatS16F32,
    HsailCvtZeroiSatU32F32,
    HsailCvtZeroiSatS32F32,
    HsailCvtZeroiSatU64F32,
    HsailCvtZeroiSatS64F32,
    HsailCvtZeroiSatU8F64,
    HsailCvtZeroiSatS8F64,
    HsailCvtZeroiSatU16F64,
    HsailCvtZeroiSatS16F64,
    HsailCvtZeroiSatU32F64,
    HsailCvtZeroiSatS32F64,
    HsailCvtZeroiSatU64F64,
    HsailCvtZeroiSatS64F64,
    // TODO: ComplexMulMin-ComplexMulMax, ComplexDivMin, ComplexDivMax, EndBuiltins
}

// TODO: autogenerate this
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TreeCode {
    ErrorMark,
    IdentifierNode,
    TreeList,
    TreeVec,
    Block,
    OffsetType,
    EnumeralType,
    BooleanType,
    IntegerType,
    RealType,
    PointerType,
    ReferenceType,
    NullptrType,
    FixedPointType,
    ComplexType,
    VectorType,
    ArrayType,
    RecordType,
    UnionType,
    QualUnionType,
    VoidType,
    FunctionType,
    MethodType,
    LangType,
    VoidCst,
    IntegerCst,
    PolyIntCst,
    RealCst,
    FixedCst,
    ComplexCst,
    VectorCst,
    StringCst,
    FunctionDecl,
    LabelDecl,
    FieldDecl,
    VarDecl,
    ConstDecl,
    ParmDecl,
    TypeDecl,
    ResultDecl,
    DebugExprDecl,
    DebugBeginStmt,
    NamespaceDecl,
    ImportedDecl,
    NamelistDecl,
    TranslationUnitDecl,
    ComponentRef,
    BitFieldRef,
    ArrayRef,
    ArrayRangeRef,
    RealpartExpr,
    ImagpartExpr,
    ViewConvertExpr,
    IndirectRef,
    ObjTypeRef,
    Constructor,
    CompoundExpr,
    ModifyExpr,
    InitExpr,
    TargetExpr,
    CondExpr,
    VecDuplicateExpr,
    VecSeriesExpr,
    VecCondExpr,
    VecPermExpr,
    BindExpr,
    CallExpr,
    WithCleanupExpr,
    CleanupPointExpr,
    PlaceholderExpr,
    PlusExpr,
    MinusExpr,
    MultExpr,
    PointerPlusExpr,
    PointerDiffExpr,
    MultHighpartExpr,
    TruncDivExpr,
    CeilDivExpr,
    FloorDivExpr,
    RoundDivExpr,
    TruncModExpr,
    CeilModExpr,
    FloorModExpr,
    RoundModExpr,
    RdivExpr,
    ExactDivExpr,
    FixTruncExpr,
    FloatExpr,
    NegateExpr,
    MinExpr,
    MaxExpr,
    AbsExpr,
    AbsuExpr,
    LShiftExpr,
    RShiftExpr,
    LRotateExpr,
    RRotateExpr,
    BitIorExpr,
    BitXorExpr,
    BitAndExpr,
    BitNotExpr,
    TruthAndifExpr,
    TruthOrifExpr,
    TruthAndExpr,
    TruthOrExpr,
    TruthXorExpr,
    TruthNotExpr,
    LtExpr,
    LeExpr,
    GtExpr,
    GeExpr,
    LtgtExpr,
    EqExpr,
    NeExpr,
    UnorderedExpr,
    OrderedExpr,
    UnltExpr,
    UnleExpr,
    UngtExpr,
    UngeExpr,
    UneqExpr,
    RangeExpr,
    ParenExpr,
    ConvertExpr,
    AddrSpaceConvertExpr,
    FixedConvertExpr,
    NopExpr,
    NonLvalueExpr,
    CompoundLiteralExpr,
    SaveExpr,
    AddrExpr,
    FdescExpr,
    BitInsertExpr,
    ComplexExpr,
    ConjExpr,
    PredecrementExpr,
    PreincrementExpr,
    PostdecrementExpr,
    PostincrementExpr,
    VaArgExpr,
    TryCatchExpr,
    TryFinallyExpr,
    EhElseExpr,
    DeclExpr,
    LabelExpr,
    GotoExpr,
    ReturnExpr,
    ExitExpr,
    LoopExpr,
    SwitchExpr,
    CaseLabelExpr,
    AsmExpr,
    SsaName,
    CatchExpr,
    EhFilterExpr,
    ScevKnown,
    ScevNotKnown,
    PolynomialChrec,
    StatementList,
    AssertExpr,
    TreeBinfo,
    WithSizeExpr,
    RealignLoadExpr,
    TargetMemRef,
    MemRef,
    OaccParallel,
    OaccKernels,
    OaccSerial,
    OaccData,
    OaccHostData,
    OmpParallel,
    OmpTask,
    OmpFor,
    OmpSimd,
    OmpDistribute,
    OmpTaskloop,
    OmpLoop,
    OaccLoop,
    OmpTeams,
    OmpTargetData,
    OmpTarget,
    OmpSections,
    OmpOrdered,
    OmpCritical,
    OmpSingle,
    OmpTaskgroup,
    OmpScan,
    OmpSection,
    OmpMaster,
    OaccCache,
    OaccDeclare,
    OaccEnterData,
    OaccExitData,
    OaccUpdate,
    OmpTargetUpdate,
    OmpTargetEnterData,
    OmpTargetExitData,
    OmpAtomic,
    OmpAtomicRead,
    OmpAtomicCaptureOld,
    OmpAtomicCaptureNew,
    OmpClause,
    TransactionExpr,
    DotProdExpr,
    WidenSumExpr,
    SadExpr,
    WidenMultExpr,
    WidenMultPlusExpr,
    WidenMultMinusExpr,
    WidenLShiftExpr,
    VecWidenMultHiExpr,
    VecWidenMultLoExpr,
    VecWidenMultEvenExpr,
    VecWidenMultOddExpr,
    VecUnpackHiExpr,
    VecUnpackLoExpr,
    VecUnpackFloatHiExpr,
    VecUnpackFloatLoExpr,
    VecUnpackFixTruncHiExpr,
    VecUnpackFixTruncLoExpr,
    VecPackTruncExpr,
    VecPackSatExpr,
    VecPackFixTruncExpr,
    VecPackFloatExpr,
    VecWidenLShiftHiExpr,
    VecWidenLShiftLoExpr,
    PredictExpr,
    OptimizationNode,
    TargetOptionNode,
    AnnotateExpr,
}

#[repr(C)]
pub struct TreeNode {
    _private: [u8; 0],
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy)]
pub struct Tree(*mut TreeNode);

pub const NULL_TREE: Tree = Tree(null_mut());

impl From<TreeIndex> for Tree {
    fn from(index: TreeIndex) -> Self {
        assert_ne!(index, TreeIndex::Max);

        Tree(unsafe { global_trees[index as usize].0 })
    }
}

impl From<IntegerTypeKind> for Tree {
    fn from(itk: IntegerTypeKind) -> Self {
        assert_ne!(itk, IntegerTypeKind::None);

        Tree(unsafe { integer_types[itk as usize].0 })
    }
}

impl From<SizeTypeKind> for Tree {
    fn from(stk: SizeTypeKind) -> Self {
        Tree(unsafe { sizetype_tab[stk as usize].0 })
    }
}

impl From<BuiltinFunction> for Tree {
    fn from(bf: BuiltinFunction) -> Self {
        unsafe { _builtin_decl_implicit(bf) }
    }
}

impl Tree {
    pub fn get_type(self) -> Self {
        unsafe { get_tree_type(self) }
    }

    pub fn get_code(self) -> TreeCode {
        unsafe { get_tree_code(self) }
    }

    pub fn get_type_size_bytes(self) -> Tree {
        unsafe { get_type_size_bytes(self) }
    }

    pub fn new_function_type(return_type: Tree, arg_types: &[Tree]) -> Self {
        unsafe { _build_function_type_array(return_type, arg_types.len(), arg_types.as_ptr()) }
    }

    pub fn new1(code: TreeCode, type_: Tree, arg0: Tree) -> Self {
        unsafe { _build1(code, type_, arg0) }
    }

    pub fn new2(code: TreeCode, type_: Tree, arg0: Tree, arg1: Tree) -> Self {
        unsafe { _build2(code, type_, arg0, arg1) }
    }

    fn new3(code: TreeCode, type_: Tree, arg0: Tree, arg1: Tree, arg2: Tree) -> Self {
        unsafe { _build3(code, type_, arg0, arg1, arg2) }
    }

    pub fn new_translation_unit_decl(name: Tree) -> Self {
        unsafe { _build_translation_unit_decl(name) }
    }

    pub fn new_init_expr(var: Tree, value: Tree) -> Self {
        Self::new2(TreeCode::InitExpr, TreeIndex::VoidType.into(), var, value)
    }

    pub fn new_int_constant<T: Into<Tree>>(int_type: T, value: i64) -> Self {
        unsafe { build_int_constant(int_type.into(), value) }
    }

    pub fn new_return_expr(value: Tree) -> Self {
        unsafe { _build1(TreeCode::ReturnExpr, TreeIndex::VoidType.into(), value) }
    }

    pub fn new_block(vars: Tree, subblocks: Tree, supercontext: Tree, chain: Tree) -> Self {
        unsafe { _build_block(vars, subblocks, supercontext, chain) }
    }

    pub fn new_bind_expr(vars: Tree, body: Tree, block: Tree) -> Self {
        let bind_expr = unsafe {
            _build3(
                TreeCode::BindExpr,
                TreeIndex::VoidType.into(),
                vars,
                body,
                block,
            )
        };

        if vars.0 != NULL_TREE.0 {
            unsafe {
                set_decl_chain_context(vars, block);
            }
        }

        bind_expr
    }

    pub fn new_result_decl(loc: Location, type_: Tree) -> Self {
        unsafe { _build_decl(loc, TreeCode::ResultDecl, NULL_TREE, type_) }
    }

    pub fn new_var_decl(loc: Location, name: Tree, type_: Tree) -> Self {
        unsafe { _build_decl(loc, TreeCode::VarDecl, name, type_) }
    }

    pub fn new_label_decl(loc: Location, context: Tree) -> Self {
        unsafe { build_label_decl(loc, context) }
    }

    pub fn new_goto(label: Tree) -> Self {
        unsafe { _build1(TreeCode::GotoExpr, TreeIndex::VoidType.into(), label) }
    }

    pub fn new_label_expr(decl: Tree) -> Self {
        unsafe { _build1(TreeCode::LabelExpr, TreeIndex::VoidType.into(), decl) }
    }

    pub fn new_cond_expr(cond: Tree, true_expr: Tree, false_expr: Tree) -> Self {
        unsafe {
            _build3(
                TreeCode::CondExpr,
                TreeIndex::VoidType.into(),
                cond,
                true_expr,
                false_expr,
            )
        }
    }

    pub fn new_case_label_expr(value: Option<Tree>, label_decl: Tree) -> Self {
        unsafe {
            _build4(
                TreeCode::CaseLabelExpr,
                TreeIndex::VoidType.into(),
                value.unwrap_or(NULL_TREE),
                NULL_TREE,
                label_decl,
                NULL_TREE,
            )
        }
    }

    pub fn new_switch_expr(switch_ty: Tree, discr: Tree, body: Tree) -> Self {
        unsafe { _build2(TreeCode::SwitchExpr, switch_ty, discr, body) }
    }

    pub fn new_record_type(code: TreeCode) -> Self {
        unsafe { _build0(code, NULL_TREE) }
    }

    pub fn finish_record_type(&mut self, mut fields: DeclList) {
        unsafe {
            finish_record_type(*self, fields.head().unwrap_or(NULL_TREE));
        }
        fields.set_context(*self);
    }

    pub fn get_record_type_field_decl(&self, index: usize) -> Self {
        unsafe { get_record_type_field_decl(*self, index) }
    }

    pub fn new_record_constructor(
        record_type: Tree,
        field_decls: &[Tree],
        field_values: &[Tree],
    ) -> Self {
        assert_eq!(field_decls.len(), field_values.len());
        unsafe {
            build_constructor_from_field_array(
                record_type,
                field_decls.len(),
                field_decls.as_ptr(),
                field_values.as_ptr(),
            )
        }
    }

    pub fn new_array_constructor(array_type: Tree, elements: &[Tree]) -> Self {
        unsafe {
            build_constructor_from_element_array(array_type, elements.len(), elements.as_ptr())
        }
    }

    pub fn new_compound_literal_expr(type_: Tree, value: Tree, context: Tree) -> Self {
        unsafe { build_compound_literal_expr(type_, value, context) }
    }

    pub fn new_component_ref(base_expr: Tree, field_decl: Tree) -> Self {
        Self::new3(
            TreeCode::ComponentRef,
            field_decl.get_type(),
            base_expr,
            field_decl,
            NULL_TREE,
        )
    }

    pub fn new_record_field_ref(base_expr: Tree, field_index: usize) -> Self {
        let field_decl = base_expr.get_type().get_record_type_field_decl(field_index);
        Self::new_component_ref(base_expr, field_decl)
    }

    pub fn new_indirect_ref(base_expr: Tree) -> Self {
        let pointer_ty = base_expr.get_type();
        assert_eq!(pointer_ty.get_code(), TreeCode::PointerType);

        // Type of dereffed item is stored in POINTER_TYPE's TREE_TYPE
        let deref_ty = pointer_ty.get_type();

        Self::new1(TreeCode::IndirectRef, deref_ty, base_expr)
    }

    pub fn new_call_expr(loc: Location, return_type: Tree, fn_ptr: Tree, args: &[Tree]) -> Self {
        unsafe { _build_call_array_loc(loc, return_type, fn_ptr, args.len(), args.as_ptr()) }
    }

    pub fn new_signed_int_type(bits: usize) -> Self {
        unsafe { _make_signed_type(bits) }
    }

    pub fn new_unsigned_int_type(bits: usize) -> Self {
        unsafe { _make_unsigned_type(bits) }
    }

    pub fn new_pointer_type(to_type: Tree) -> Self {
        unsafe { _build_pointer_type(to_type) }
    }

    pub fn new_addr_expr(value: Tree) -> Self {
        unsafe {
            _build1(
                TreeCode::AddrExpr,
                Tree::new_pointer_type(value.get_type()),
                value,
            )
        }
    }

    pub fn new_array_type(element_type: Tree, num_elements: u64) -> Self {
        unsafe { _build_array_type_nelts(element_type, num_elements) }
    }

    pub fn new_array_index_ref(element_type: Tree, array_expr: Tree, index_expr: Tree) -> Self {
        unsafe {
            _build4(
                TreeCode::ArrayRef,
                element_type,
                array_expr,
                index_expr,
                NULL_TREE,
                NULL_TREE,
            )
        }
    }

    pub fn set_static(&mut self, value: bool) {
        unsafe {
            set_tree_static(*self, value);
        }
    }

    pub fn set_public(&mut self, value: bool) {
        unsafe {
            set_tree_public(*self, value);
        }
    }

    pub fn set_decl_context(&mut self, context: Tree) {
        unsafe {
            set_decl_context(*self, context);
        }
    }

    pub fn set_decl_initial(&mut self, value: Tree) {
        unsafe {
            set_decl_initial(*self, value);
        }
    }

    pub fn finalize_decl(&mut self) {
        unsafe {
            finalize_decl(*self);
        }
    }

    pub fn new_identifier(name: impl Into<Vec<u8>>) -> Tree {
        let name = CString::new(name).unwrap();

        unsafe { _get_identifier(name.as_ptr()) }
    }
}

extern "C" {
    static global_trees: [Tree; TreeIndex::Max as usize];
    static integer_types: [Tree; IntegerTypeKind::None as usize];
    // TODO: array size should be autogenerated
    static sizetype_tab: [Tree; 4];

    static crate_type: Option<NonNull<c_char>>;

    fn _alloc_stmt_list() -> Tree;
    fn _append_to_statement_list(stmt: Tree, list: *mut Tree);
    fn _build0(code: TreeCode, tt: Tree) -> Tree;
    fn _build1(code: TreeCode, tt: Tree, arg0: Tree) -> Tree;
    fn _build2(code: TreeCode, tt: Tree, arg0: Tree, arg1: Tree) -> Tree;
    fn _build3(code: TreeCode, tt: Tree, arg0: Tree, arg1: Tree, arg2: Tree) -> Tree;
    fn _build4(code: TreeCode, tt: Tree, arg0: Tree, arg1: Tree, arg2: Tree, arg3: Tree) -> Tree;
    fn _build5(
        code: TreeCode,
        tt: Tree,
        arg0: Tree,
        arg1: Tree,
        arg2: Tree,
        arg3: Tree,
        arg4: Tree,
    ) -> Tree;
    fn _build_decl(loc: Location, code: TreeCode, name: Tree, tt: Tree) -> Tree;
    fn _build_translation_unit_decl(name: Tree) -> Tree;
    fn _build_string_literal(
        len: usize,
        string: *const c_char,
        eltype: Tree,
        size: c_ulong,
    ) -> Tree;
    fn _build_block(vars: Tree, subblocks: Tree, supercontext: Tree, chain: Tree) -> Tree;
    fn _build_call_array_loc(
        loc: Location,
        returntype: Tree,
        fn_ptr: Tree,
        num_args: usize,
        args: *const Tree,
    ) -> Tree;
    fn _build_pointer_type(totype: Tree) -> Tree;
    fn _build_function_type_array(
        returntype: Tree,
        num_args: usize,
        arg_types: *const Tree,
    ) -> Tree;
    fn _build_fn_decl(name: *const c_char, decltype: Tree) -> Tree;
    fn _gimplify_function_tree(tree: Tree);
    fn _builtin_decl_implicit(fncode: BuiltinFunction) -> Tree;
    fn _build_array_type_nelts(elt_type: Tree, nelts: u64) -> Tree;
    fn _make_signed_type(bits: usize) -> Tree;
    fn _make_unsigned_type(bits: usize) -> Tree;
    fn _get_identifier(name: *const c_char) -> Tree;

    fn build_constructor_from_field_array(
        type_: Tree,
        num_fields: usize,
        field_decls: *const Tree,
        field_values: *const Tree,
    ) -> Tree;

    fn build_constructor_from_element_array(
        type_: Tree,
        num_elements: usize,
        elements: *const Tree,
    ) -> Tree;

    fn get_tree_type(tree: Tree) -> Tree;
    fn get_tree_code(tree: Tree) -> TreeCode;
    fn get_type_size_bytes(tree: Tree) -> Tree;
    fn build_int_constant(inttype: Tree, value: i64) -> Tree;
    fn build_label_decl(loc: Location, context: Tree) -> Tree;
    fn set_tree_static(tree: Tree, value: bool);
    fn set_tree_public(tree: Tree, value: bool);
    fn make_decl_chain(code: TreeCode, num_decls: usize, types: *const Tree, decls: *mut Tree);
    fn set_decl_context(decl: Tree, context: Tree);
    fn set_decl_initial(decl: Tree, value: Tree);
    fn set_decl_chain_context(chain_head: Tree, context: Tree);
    fn finish_record_type(record_type: Tree, fields_chain_head: Tree) -> Tree;
    fn get_record_type_field_decl(record_type: Tree, index: usize) -> Tree;
    fn build_compound_literal_expr(type_: Tree, value: Tree, context: Tree) -> Tree;
    fn set_fn_result(fn_decl: Tree, result: Tree);
    fn set_fn_initial(fn_decl: Tree, tree: Tree);
    fn set_fn_saved_tree(fn_decl: Tree, tree: Tree);
    fn set_fn_external(fn_decl: Tree, value: bool);
    fn set_fn_preserve_p(fn_decl: Tree, value: bool);
    fn attach_fn_parm_decls(fn_decl: Tree, decl_chain: Tree);
    fn finalize_decl(tree: Tree);
    fn finalize_function(tree: Tree, no_collect: bool);
}

#[derive(Debug)]
pub struct StatementList(pub Tree);

impl StatementList {
    pub fn new() -> Self {
        Self(unsafe { _alloc_stmt_list() })
    }

    pub fn push(&mut self, stmt: Tree) {
        unsafe {
            _append_to_statement_list(stmt, &mut self.0);
        }
    }
}

#[derive(Debug)]
pub struct DeclList(Vec<Tree>);

impl DeclList {
    pub fn new(code: TreeCode, types: &[Tree]) -> Self {
        let mut decls = vec![NULL_TREE; types.len()];

        unsafe {
            make_decl_chain(code, types.len(), types.as_ptr(), decls.as_mut_ptr());
        }

        DeclList(decls)
    }

    pub fn head(&self) -> Option<Tree> {
        self.0.first().copied()
    }

    pub fn set_context(&mut self, context: Tree) {
        if let Some(decl) = self.head() {
            unsafe {
                set_decl_chain_context(decl, context);
            }
        }
    }
}

impl std::ops::Deref for DeclList {
    type Target = [Tree];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy)]
pub struct Function(pub Tree);

impl Function {
    pub fn new(name: &CStr, type_: Tree) -> Self {
        Self(unsafe { _build_fn_decl(name.as_ptr(), type_) })
    }

    pub fn set_result(&mut self, result: Tree) {
        unsafe {
            set_fn_result(self.0, result);
        }
    }

    pub fn set_initial(&mut self, tree: Tree) {
        unsafe {
            set_fn_initial(self.0, tree);
        }
    }

    pub fn set_saved_tree(&mut self, tree: Tree) {
        unsafe {
            set_fn_saved_tree(self.0, tree);
        }
    }

    pub fn set_external(&mut self, value: bool) {
        unsafe {
            set_fn_external(self.0, value);
        }
    }

    pub fn set_preserve_p(&mut self, value: bool) {
        unsafe {
            set_fn_preserve_p(self.0, value);
        }
    }

    pub fn attach_parm_decls(&mut self, decls: &DeclList) {
        unsafe {
            attach_fn_parm_decls(self.0, decls.head().unwrap_or(NULL_TREE));
        }
    }

    pub fn gimplify(&mut self) {
        unsafe {
            _gimplify_function_tree(self.0);
        }
    }

    pub fn finalize(&mut self) {
        unsafe {
            finalize_function(self.0, true);
        }
    }
}
